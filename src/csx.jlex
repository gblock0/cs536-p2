/*  This is a JLex specification for a small subset of CSX tokens.
    Expand it to handle all CSX tokens as part of your solution for project 2 */


/* Written by  Victor Ferrero (906 337 5068) and  Jamie Holt (906 573 7984) */

// NOTE that we added 3 token classes that extend CSXToken:
// CSXReservedWordToken, CSXInvalidToken, and CSXOtherToken
import java_cup.runtime.*;

class CSXToken {
	int linenum;
	int colnum;
	CSXToken(int line,int col){
		linenum=line;colnum=col;};
}


class CSXReservedWordToken extends CSXToken{
// used only for Reserve words
	String stringText;
	CSXReservedWordToken(String text, int line, int col) {
		super(line,col); stringText = text;
	};
}

class CSXOtherToken extends CSXToken{
// used for "other" tokens, like +,-,=,==, etc
	String stringText;
	CSXOtherToken(String text, int line, int col) {
		super(line,col); stringText = text;
	};
}

class CSXInvalidToken extends CSXToken{
// used for invalid tokens
	String stringText;
	CSXInvalidToken(String text, int line, int col) {
		super(line,col); stringText = text;
	};
}

class CSXIntLitToken extends CSXToken {
	int intValue;
	CSXIntLitToken(int val,int line,int col){
		super(line,col);intValue=val;};
}

class CSXIdentifierToken extends CSXToken {
	String identifierText;
	CSXIdentifierToken(String text,int line,int col){
		super(line,col);identifierText=text;};
}

class CSXCharLitToken extends CSXToken {
	String charValue; // changed this to string to not have to deal with casting from string yytext() to character
	CSXCharLitToken(String val,int line,int col){
		super(line,col);charValue=val;};
}

class CSXStringLitToken extends CSXToken {
	String stringText; // Full text of string literal,
                          //  including quotes & escapes
	CSXStringLitToken(String text,int line,int col){
		super(line,col);
		stringText=text;
	};
}

// This class is used to track line and column numbers
// Please feel free to change or extend it

class Pos {
	static int  linenum = 1; /* maintain this as line number current
                                 token was scanned on */
	static int  colnum = 1; /* maintain this as column number current
                                 token began at */
	static int  line = 1; /* maintain this as line number after
					scanning current token  */
	static int  col = 1; /* maintain this as column number after
					scanning current token  */
	static void setpos() { // set starting position for current token
		linenum = line;
		colnum = col;
	}
}

%%
Digit=[0-9]
upperCaseLetter = [A-Z]
lowerCaseLetter = [a-z]
letters = [A-Za-z]
whitespace = [\040\t]
doubleQuote = [\"]
singleQuote = [\']
newline = [\n]
tab = [\t]
singleComment = [^\n]
identifier=({letters})({letters}|{Digit})*
notPOUNDSIGN = [^#]
emptyString = []
string = ([^\n\"\\]|\\[\\nt\"'])*
char = ([^\n\"\\]|\\[\\nt\"'])
backslash = [\\]
escapeCharacter = [\n]

// reserved word macros to deal with case insensitivity 
bool = [Bb][Oo][Oo][Ll]
break = [Bb][Rr][Ee][Aa][Kk]
char = [Cc][Hh][Aa][Rr]
class = [Cc][Ll][Aa][Ss][Ss]
const = [Cc][Oo][Nn][Ss][Tt]
continue = [Cc][Oo][Nn][Tt][Ii][Nn][Uu][Ee]
else = [Ee][Ll][Ss][Ee]
false = [Ff][Aa][Ll][Ss][Ee]
if = [Ii][Ff]
int = [Ii][Nn][Tt]
read = [Rr][Ee][Aa][Dd]
return = [Rr][Ee][Tt][Uu][Rr][Nn]
true = [Tt][Rr][Uu][Ee]
void = [Vv][Oo][Ii][Dd]
while = [Ww][Hh][Ii][Ll][Ee]
print = [Pp][Rr][Ii][Nn][Tt]


// Tell JLex to have yylex() return a Symbol, as JavaCUP will require
%type Symbol

// Tell JLex what to return when eof of file is hit
%eofval{
return new Symbol(sym.EOF, new  CSXToken(0,0));
%eofval}
%line
%notunix
%%

{bool}		{ 
// START of reserve words
			Pos.setpos();
			Pos.col+= yytext().length();
			return new Symbol(sym.rw_BOOL, new CSXReservedWordToken("BOOL", Pos.linenum, Pos.colnum)); 
			} 
{break} 	{ 
			Pos.setpos();
			Pos.col+= yytext().length();
			return new Symbol(sym.rw_BREAK, new CSXReservedWordToken("BREAK", Pos.linenum, Pos.colnum)); 
			}
{char} 		{ 
			Pos.setpos();
			Pos.col+= yytext().length();
			return new Symbol(sym.rw_CHAR, new CSXReservedWordToken("CHAR", Pos.linenum, Pos.colnum)); 
			}
{class} 	{ 
			Pos.setpos();
			Pos.col+= yytext().length();
			return new Symbol(sym.rw_CLASS, new CSXReservedWordToken("CLASS", Pos.linenum, Pos.colnum));
			 }
{const} 	{
			Pos.setpos();
			Pos.col+= yytext().length();
			return new Symbol(sym.rw_CONST, new CSXReservedWordToken("CONST", Pos.linenum, Pos.colnum)); 
			}
{continue} 	{ 
			Pos.setpos();
			Pos.col+= yytext().length();
			return new Symbol(sym.rw_CONTINUE, new CSXReservedWordToken("CONTINUE", Pos.linenum, Pos.colnum));  
			}
{else} 		{ 
			Pos.setpos();
			Pos.col+= yytext().length();
			return new Symbol(sym.rw_ELSE, new CSXReservedWordToken("ELSE", Pos.linenum, Pos.colnum));  
			}
{false} 	{ 
			Pos.setpos();
			Pos.col+= yytext().length();
			return new Symbol(sym.rw_FALSE, new CSXReservedWordToken("FALSE", Pos.linenum, Pos.colnum));  
			}
{if} 		{ 
			Pos.setpos();
			Pos.col+= yytext().length();
			return new Symbol(sym.rw_IF, new CSXReservedWordToken("IF", Pos.linenum, Pos.colnum));  
			}
{int} 		{
			Pos.setpos();
			Pos.col+= yytext().length();
			return new Symbol(sym.rw_INT, new CSXReservedWordToken("INT", Pos.linenum, Pos.colnum));  
			}
{print} 	{ 
			Pos.setpos();
			Pos.col+= yytext().length();
			return new Symbol(sym.rw_PRINT, new CSXReservedWordToken("PRINT", Pos.linenum, Pos.colnum)); 
			}
 {read} 		{ 
			Pos.setpos();
			Pos.col+= yytext().length();
			return new Symbol(sym.rw_READ, new CSXReservedWordToken("READ", Pos.linenum, Pos.colnum)); 
			}
{return} 	{ 
			Pos.setpos();
			Pos.col+= yytext().length();
			return new Symbol(sym.rw_RETURN, new CSXReservedWordToken("RETURN", Pos.linenum, Pos.colnum)); 
			}
{true} 		{ 
			Pos.setpos();
			Pos.col+= yytext().length();
			return new Symbol(sym.rw_TRUE, new CSXReservedWordToken("TRUE", Pos.linenum, Pos.colnum)); 
			}
{void} 		{
			Pos.setpos();
			Pos.col+= yytext().length();
			return new Symbol(sym.rw_VOID, new CSXReservedWordToken("VOID", Pos.linenum, Pos.colnum));  
			}
 {while} 	{
			Pos.setpos();
			Pos.col+= yytext().length();
			return new Symbol(sym.rw_WHILE, new CSXReservedWordToken("WHILE", Pos.linenum, Pos.colnum));  	
			// END of reserved words
			}
					
"(" {
// START of "other" tokens
		Pos.setpos();
		Pos.col += yytext().length();
		return new Symbol(sym.LPAREN, new CSXOtherToken("(", Pos.linenum,Pos.colnum));
}

")" {
		Pos.setpos();
		Pos.col +=yytext().length();
		return new Symbol(sym.RPAREN, new CSXOtherToken(")", Pos.linenum,Pos.colnum));
}
 
"[" {
		Pos.setpos();
		Pos.col +=yytext().length();
		return new Symbol(sym.LBRACKET, new CSXOtherToken("[", Pos.linenum,Pos.colnum));}
"]" {
		Pos.setpos();
		Pos.col +=yytext().length();
		return new Symbol(sym.RBRACKET, new CSXOtherToken("]", Pos.linenum,Pos.colnum));
}
"=" {
		Pos.setpos();
		Pos.col +=yytext().length();
		return new Symbol(sym.ASG, new CSXOtherToken("=", Pos.linenum,Pos.colnum));
}
";"	{
		Pos.setpos();
		Pos.col +=yytext().length();
		return new Symbol(sym.SEMI, new CSXOtherToken(";", Pos.linenum,Pos.colnum));
		}
"+" {
		Pos.setpos(); 
		Pos.col +=1;
		return new Symbol(sym.PLUS, new CSXOtherToken("+", Pos.linenum,Pos.colnum));
}
"-" {
		Pos.setpos();
		Pos.col +=yytext().length();
		return new Symbol(sym.MINUS, new CSXOtherToken("-", Pos.linenum,Pos.colnum));
}
"*" {
		Pos.setpos();
		Pos.col +=yytext().length();
		return new Symbol(sym.TIMES, new CSXOtherToken("*", Pos.linenum,Pos.colnum));
}
"/" {
		Pos.setpos();
		Pos.col +=yytext().length();
		return new Symbol(sym.SLASH, new CSXOtherToken("/", Pos.linenum,Pos.colnum));
}
"==" {
		Pos.setpos();
		Pos.col +=yytext().length();
		return new Symbol(sym.EQ, new CSXOtherToken("==", Pos.linenum,Pos.colnum));
} 
"!="	{
		Pos.setpos();
		Pos.col +=2;
		return new Symbol(sym.NOTEQ, new CSXOtherToken("!=", Pos.linenum,Pos.colnum));
		}	
"&&" {
		Pos.setpos();
		Pos.col +=yytext().length();
		return new Symbol(sym.CAND, new CSXOtherToken("&&", Pos.linenum,Pos.colnum));
}
"||" {
		Pos.setpos();
		Pos.col +=yytext().length();
		return new Symbol(sym.COR, new CSXOtherToken("||", Pos.linenum,Pos.colnum));
}
"<" {
		Pos.setpos();
		Pos.col +=yytext().length();
		return new Symbol(sym.LT, new CSXOtherToken("<", Pos.linenum,Pos.colnum));
}
">" {
		Pos.setpos();
		Pos.col +=yytext().length();
		return new Symbol(sym.GT, new CSXOtherToken(">", Pos.linenum,Pos.colnum));
}
"<=" {
		Pos.setpos();
		Pos.col +=yytext().length();
		return new Symbol(sym.LEQ, new CSXOtherToken("<=", Pos.linenum,Pos.colnum));
}
">=" {
		Pos.setpos();
		Pos.col +=yytext().length();
		return new Symbol(sym.GEQ, new CSXOtherToken(">=", Pos.linenum,Pos.colnum));
} 
"," {
		Pos.setpos();
		Pos.col +=yytext().length();
		return new Symbol(sym.COMMA, new CSXOtherToken(",", Pos.linenum,Pos.colnum));
}
"!" {
		Pos.setpos();
		Pos.col +=yytext().length();
		return new Symbol(sym.NOT, new CSXOtherToken("!", Pos.linenum,Pos.colnum));
} 
"{" {
		Pos.setpos();
		Pos.col +=yytext().length();
		return new Symbol(sym.LBRACE, new CSXOtherToken("\173", Pos.linenum,Pos.colnum));
		//Used Octal representation of LBRACE because syntax error was thrown otherwise
}
"}" {
		Pos.setpos();
		Pos.col +=yytext().length();
		return new Symbol(sym.RBRACE, new CSXOtherToken("\175", Pos.linenum,Pos.colnum));
				//Used Octal representation of RBRACE because syntax error was thrown otherwise
}
":" {
		Pos.setpos();
		Pos.col +=yytext().length();
		return new Symbol(sym.COLON, new CSXOtherToken(":", Pos.linenum,Pos.colnum));
} 
"++" {
		Pos.setpos();
		Pos.col +=yytext().length();
		return new Symbol(sym.INCREMENT, new CSXOtherToken("++", Pos.linenum,Pos.colnum));
}
"--" {
		Pos.setpos();
		Pos.col +=yytext().length();
		return new Symbol(sym.DECREMENT, new CSXOtherToken("--", Pos.linenum,Pos.colnum));
// END of "other" tokens
} 
			
("//")({singleComment})*({newline}) {
//Single line comment
		Pos.line +=1; 
		Pos.col = 1;
}

("##")(((#)?{notPOUNDSIGN})*)("##") {
//Multi-line comment
	String value = yytext();
	// multi line comments dont always have newline char
	if(value.contains("\n")) {
		String[] strSplit = value.split("\n");
		String lastLine = strSplit[strSplit.length - 1];	
		Pos.col += lastLine.length();
		Pos.line += strSplit.length - 1; 
	}
	else {
		Pos.col += yytext().length();
	}
}

{Digit}+ {
//Positive Integer Literal
			Pos.setpos(); 
		  	Pos.col += yytext().length();
			String value = yytext();
			double doubleValue = Double.parseDouble(value); // check for overflow by parsing int as double
	// do overflow check
	if(doubleValue > Integer.MAX_VALUE) {
		doubleValue = 2147483647.0;
		System.out.println(Pos.linenum + ":" + Pos.colnum + " " + "Error: Integer literal " + value + " too large; replaced with 2147483647");
	//	Errors.fatal(Pos.linenum, Pos.colnum, "Integer literal too large: using max value");
	// above call to Errors.fatal was not working
	}
	int intValue = (int) doubleValue; // cast back to integer
	Symbol s = new Symbol(sym.INTLIT, new CSXIntLitToken(intValue, Pos.linenum, Pos.colnum));
	return s;
}

(~|{emptyString})({Digit})+ {  // created different rule to deal with negative int literal
//Negative Integer Literal
			Pos.setpos(); 
		  	Pos.col += yytext().length();
			String value = yytext();
			value = value.substring(1, value.length());
			double doubleValue = Double.parseDouble(value) * -1; // parse int as double, and make it negative
	
	if (doubleValue < Integer.MIN_VALUE){
		doubleValue = -2147483648.0;
		System.out.println(Pos.linenum + ":" + Pos.colnum + " " + "Error: Integer literal ~" + value + " too small; replaced with -2147483648");
//		Errors.fatal(Pos.linenum, Pos.colnum, "Integer literal too large: using min value");
// above call to Errors.fatal was not working
	}
	
	int intValue = (int) doubleValue;
	Symbol s = new Symbol(sym.INTLIT, new CSXIntLitToken(intValue, Pos.linenum, Pos.colnum));
	return s;
}

{doubleQuote}{doubleQuote} {
// empty string
	Pos.setpos(); 
	Pos.col += yytext().length();
	String value = ""; 
	Symbol s = new Symbol(sym.STRLIT, new CSXStringLitToken(value, Pos.linenum, Pos.colnum));
	return s;
}

{singleQuote}(({backslash}{backslash})|({backslash}({singleQuote}|{doubleQuote}))){singleQuote} {
// character literal either \\, \', or \"
	Pos.setpos(); 
	Pos.col += yytext().length();
	String s1 = yytext();
	String[] letters = s1.split("");
	String value = letters[3]; // expected this to be at letters[2], but when i print out string theres an extra index in string[] array
	Symbol s = new Symbol(sym.CHARLIT, new CSXCharLitToken(value, Pos.linenum, Pos.colnum));
	return s;
}

{singleQuote}("\n"|"\t"){singleQuote} {
// character literal either \n or \t
	Pos.setpos(); 
	Pos.col += yytext().length();
	String s1 = yytext().substring(1, yytext().length() - 1); // remove the single quotes from string
	String[] letters = s1.split("");
	String value = letters[1] + letters[2];
	Symbol s = new Symbol(sym.CHARLIT, new CSXCharLitToken(value, Pos.linenum, Pos.colnum));
	return s;
}

{singleQuote}({upperCaseLetter}|{lowerCaseLetter}|{Digit}){singleQuote} {
//Character Literal that is just a letter or digit, no escaped characters
	Pos.setpos(); 
	Pos.col += yytext().length();
	String value = yytext();
	value = value.substring(1, value.length() - 1); // remove the single quotes from string
	Symbol s = new Symbol(sym.CHARLIT, new CSXCharLitToken(value, Pos.linenum, Pos.colnum));
	return s;
}

{doubleQuote}{string}{doubleQuote} {
//String Literal
	Pos.setpos(); 
	Pos.col += yytext().length();
	String value = yytext();
	Symbol s = new Symbol(sym.STRLIT, new CSXStringLitToken(value, Pos.linenum, Pos.colnum));
	return s;
}

({identifier})  {
//This is an ID
	String value = yytext();
	Pos.setpos();
	Pos.col += yytext().length();
	Symbol s = new Symbol(sym.IDENTIFIER, new CSXIdentifierToken(value, Pos.linenum, Pos.colnum)); //update Pos.linenum?
	return s;
}

{whitespace}+ {
//whitespace
	Pos.col += yytext().length();
}

{newline} {//newline
				Pos.line +=1; 
				Pos.col = 1;
			}
			
. {  // this is for invalid tokens
		Pos.setpos();
		Pos.col +=yytext().length();
		return new Symbol(-1, new CSXInvalidToken(yytext(), Pos.linenum, Pos.colnum));
}

